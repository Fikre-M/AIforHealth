import { Types } from 'mongoose';
import AIAssistant, { IAIConversation, IAIMessage, AIConversationStatus } from '../models/AIAssistant';
import { UserRole } from '@/types';

class AIAssistantService {
  /**
   * Create a new AI conversation
   */
  async createConversation(userId: Types.ObjectId, initialMessage: string): Promise<IAIConversation> {
    const conversation = new AIAssistant({
      user: userId,
      title: 'New Conversation',
      messages: [{
        role: 'user',
        content: initialMessage,
        timestamp: new Date()
      }],
      status: AIConversationStatus.ACTIVE
    });

    return conversation.save();
  }

  /**
   * Add a message to an existing conversation
   */
  async addMessage(
    conversationId: string, 
    userId: Types.ObjectId, 
    role: 'user' | 'assistant' | 'system', 
    content: string,
    metadata?: Record<string, any>
  ): Promise<IAIConversation | null> {
    const message = {
      role,
      content,
      timestamp: new Date(),
      metadata: metadata || {}
    };

    return AIAssistant.findOneAndUpdate(
      { _id: conversationId, user: userId },
      { 
        $push: { messages: message },
        $set: { updatedAt: new Date() }
      },
      { new: true }
    );
  }

  /**
   * Get a conversation by ID
   */
  async getConversation(conversationId: string, userId: Types.ObjectId): Promise<IAIConversation | null> {
    return AIAssistant.findOne({ _id: conversationId, user: userId });
  }

  /**
   * List all conversations for a user
   */
  async listConversations(
    userId: Types.ObjectId, 
    { limit = 20, page = 1, status }: { limit?: number; page?: number; status?: AIConversationStatus } = {}
  ) {
    const query: any = { user: userId };
    if (status) {
      query.status = status;
    }

    const [conversations, total] = await Promise.all([
      AIAssistant.find(query)
        .sort({ updatedAt: -1 })
        .skip((page - 1) * limit)
        .limit(limit)
        .select('-messages')
        .lean(),
      AIAssistant.countDocuments(query)
    ]);

    return {
      data: conversations,
      pagination: {
        total,
        page,
        totalPages: Math.ceil(total / limit),
        limit
      }
    };
  }

  /**
   * Update conversation status
   */
  async updateConversationStatus(
    conversationId: string, 
    userId: Types.ObjectId, 
    status: AIConversationStatus
  ): Promise<IAIConversation | null> {
    return AIAssistant.findOneAndUpdate(
      { _id: conversationId, user: userId },
      { 
        status,
        $set: { updatedAt: new Date() }
      },
      { new: true }
    );
  }

  /**
   * Delete a conversation
   */
  async deleteConversation(conversationId: string, userId: Types.ObjectId): Promise<boolean> {
    const result = await AIAssistant.deleteOne({ _id: conversationId, user: userId });
    return result.deletedCount > 0;
  }

  /**
   * Process user input and generate a response (placeholder implementation)
   */
  async processUserInput(
    conversationId: string, 
    userId: Types.ObjectId, 
    userInput: string
  ): Promise<{ response: string; conversation: IAIConversation | null }> {
    // Save user message
    const updatedConversation = await this.addMessage(
      conversationId,
      userId,
      'user',
      userInput
    );

    if (!updatedConversation) {
      throw new Error('Conversation not found');
    }

    // This is a placeholder response
    // In a real implementation, this would call an AI service
    const aiResponse = this.generatePlaceholderResponse(userInput);

    // Save AI response
    await this.addMessage(
      conversationId,
      userId,
      'assistant',
      aiResponse,
      { 
        isPlaceholder: true,
        disclaimer: 'This is a placeholder response. In a real implementation, this would be generated by an AI model.'
      }
    );

    return {
      response: aiResponse,
      conversation: await this.getConversation(conversationId, userId)
    };
  }

  /**
   * Generate a placeholder response based on user input
   */
  private generatePlaceholderResponse(userInput: string): string {
    const lowerInput = userInput.toLowerCase();
    
    if (lowerInput.includes('symptom') || lowerInput.includes('pain') || lowerInput.includes('hurt')) {
      return "I understand you're experiencing some symptoms. While I can provide general information, it's important to consult with a healthcare professional for an accurate diagnosis. Could you tell me more about your symptoms, including when they started and how severe they are?";
    }
    
    if (lowerInput.includes('appointment') || lowerInput.includes('schedule') || lowerInput.includes('see a doctor')) {
      return "I can help you schedule an appointment. Would you like me to check available time slots with a healthcare provider? You can also view available appointments through our appointment booking system.";
    }
    
    if (lowerInput.includes('medication') || lowerInput.includes('prescription')) {
      return "For medication-related questions, it's best to consult with your healthcare provider or pharmacist. They can provide personalized advice based on your medical history and current prescriptions.";
    }
    
    return "Thank you for your message. I'm an AI assistant designed to help with general health information. For specific medical advice, please consult with a healthcare professional. How can I assist you today?";
  }

  /**
   * Get conversation history for a user
   */
  async getConversationHistory(userId: Types.ObjectId, limit: number = 5): Promise<Array<{
    _id: Types.ObjectId;
    title: string;
    lastMessage: string;
    updatedAt: Date;
  }>> {
    const conversations = await AIAssistant.aggregate([
      { $match: { user: userId } },
      { $sort: { updatedAt: -1 } },
      { $limit: limit },
      {
        $project: {
          _id: 1,
          title: 1,
          lastMessage: { $arrayElemAt: ['$messages', -1] },
          updatedAt: 1
        }
      },
      {
        $project: {
          _id: 1,
          title: 1,
          lastMessage: '$lastMessage.content',
          updatedAt: 1
        }
      }
    ]);

    return conversations;
  }
}

export default new AIAssistantService();
